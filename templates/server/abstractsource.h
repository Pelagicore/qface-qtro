{% set class = '{0}AbstractSource'.format(interface) %}
#ifndef REP_{{interface|upper}}_SOURCE_H
#define REP_{{interface|upper}}_SOURCE_H

// This is an autogenerated file.
// Do not edit this file, any changes made will be lost the next time it is generated.

#include <QtCore>
#include <QtRemoteObjects>

{% for property in interface.properties %}
{% if property.type.is_model and property.type.nested.is_complex %}
#include "qml{{property.type.nested|lower}}model.h"
{% endif %}
{% endfor %}
#include "qmlvariantmodel.h"

class {{class}} : public QObject
{
  Q_OBJECT
  Q_CLASSINFO(QCLASSINFO_REMOTEOBJECT_TYPE, "{{interface}}")
  Q_CLASSINFO(QCLASSINFO_REMOTEOBJECT_SIGNATURE, "{{interface|hash}}")
{% for property in interface.properties %}
{% if not property.type.is_model %}
  Q_PROPERTY({{property|returnType}} {{property}} READ {{property}} {% if not property.readonly %}WRITE set{{property|upperfirst}} {% endif %}{% if not property.const %}NOTIFY {{property}}Changed{% endif %})
{% endif %}
{% endfor %}

public:
    explicit {{class}}(QObject *parent = nullptr);
public:
    virtual ~{{class}}();

{% for property in interface.properties %}
    virtual {{property|returnType}} {{property}}() const;
{% endfor %}
{% for property in interface.properties %}
    virtual void set{{property|upperfirst}}({{property|parameterType}});
{% endfor %}

Q_SIGNALS:
{% for property in interface.properties %}
    void {{property}}Changed({{property|returnType}});
{% endfor %}
{% for signal in interface.signals %}
    void {{signal}}({{signal|parameters}});
{% endfor %}

public Q_SLOTS:
{% for property in interface.properties %}
    virtual void push{{property|upperfirst}}({{property|parameters}})
    {
        set{{property|upperfirst}}({{property}});
    }
{% endfor %}
{% for operation in interface.operations %}
    virtual {{operation|returnType}} {{operation}}({{operation|parameters}});
{% endfor %}

private:
{% for property in interface.properties if property.type.is_model and property.type.nested.is_complex %}
    Qml{{property.type.nested}}Model *m_{{property|lowerfirst}};
{% endfor %}
{% for property in interface.properties if property.type.is_model and property.type.nested.is_primitive %}
    QmlVariantModel * m_{{property|lowerfirst}};
{% endfor %}
    friend class QT_PREPEND_NAMESPACE(QRemoteObjectNode);
};

#if (QT_VERSION < QT_VERSION_CHECK(5, 5, 0))
#endif

template <class ObjectType>
struct {{class}}API : public SourceApiMap
{
    {{class}}API()
        : SourceApiMap()
    {
        _properties[0] = {{interface.properties|length}};
{%for property in interface.properties %}
        _properties[{{loop.index}}] = qtro_prop_index<ObjectType>(&ObjectType::{{property}}, static_cast<{{property|returnType}} (QObject::*)()>(0),"{{property}}");
        qtro_method_test<ObjectType>(&ObjectType::{{property}}Changed, static_cast<void (QObject::*)()>(0));
{% endfor %}
{% set signals = interface.properties|list + interface.signals|list %}
        _signals[0] = {{signals|length}};
{%for signal in signals%}
        _signals[{{loop.index}}] = qtro_signal_index<ObjectType>(&ObjectType::{{signal}}Changed, static_cast<void (QObject::*)()>(0),signalArgCount+{{loop.index0}},&signalArgTypes[{{loop.index0}}]);
{% endfor %}
        _methods[0] = {{interface.operations|length + interface.properties|length}};
{% for property in interface.properties %}
        _methods[{{loop.index}}] = qtro_method_index<ObjectType>(&ObjectType::push{{property|upperfirst}}, static_cast<void (QObject::*)({{property|signature}})>(0),"push{{property|upperfirst}}({{property|parameters('returnType')}})",methodArgCount+{{loop.index0}},&methodArgTypes[{{loop.index0}}]);
{% endfor %}
{% set offset = interface.properties|length %}
{% for operation in interface.operations %}
        {% set index = loop.index0 + offset %}
        _methods[{{index+1}}] = qtro_method_index<ObjectType>(&ObjectType::{{operation}}, static_cast<void (QObject::*)({{operation|signature}})>(0),"{{operation}}({{operation|parameters('returnType')}})",methodArgCount+{{index}},&methodArgTypes[{{index}}]);
{% endfor %}
    }

    QString name() const override { return QStringLiteral("{{interface}}"); }
    QString typeName() const override { return QStringLiteral("{{interface}}"); }
    int propertyCount() const override { return _properties[0]; }
    int signalCount() const override { return _signals[0]; }
    int methodCount() const override { return _methods[0]; }
    int sourcePropertyIndex(int index) const override
    {
        if (index < 0 || index >= _properties[0])
            return -1;
        return _properties[index+1];
    }
    int sourceSignalIndex(int index) const override
    {
        if (index < 0 || index >= _signals[0])
            return -1;
        return _signals[index+1];
    }
    int sourceMethodIndex(int index) const override
    {
        if (index < 0 || index >= _methods[0])
            return -1;
        return _methods[index+1];
    }
    int signalParameterCount(int index) const override
    {
        if (index < 0 || index >= _signals[0])
            return -1;
        return signalArgCount[index];
    }
    int signalParameterType(int sigIndex, int paramIndex) const override
    {
        if (sigIndex < 0 || sigIndex >= _signals[0] || paramIndex < 0 || paramIndex >= signalArgCount[sigIndex])
            return -1;
        return signalArgTypes[sigIndex][paramIndex];
    }
    int methodParameterCount(int index) const override
    {
        if (index < 0 || index >= _methods[0])
            return -1;
        return methodArgCount[index];
    }
    int methodParameterType(int methodIndex, int paramIndex) const override
    {
        if (methodIndex < 0 || methodIndex >= _methods[0] || paramIndex < 0 || paramIndex >= methodArgCount[methodIndex])
            return -1;
        return methodArgTypes[methodIndex][paramIndex];
    }
    int propertyIndexFromSignal(int index) const override
    {
        switch (index) {
{% for property in interface.properties %}
        case {{loop.index0}}: return _properties[{{loop.index}}];
{% endfor %}
        }
        return -1;
    }
    int propertyRawIndexFromSignal(int index) const override
    {
        switch (index) {
{% for property in interface.properties %}
        case {{loop.index0}}: return {{loop.index}};
{% endfor %}
        }
        return -1;
    }
    const QByteArray signalSignature(int index) const override
    {
        switch (index) {
{% for signal in signals %}
        case {{loop.index0}}: return QByteArrayLiteral("{{signal|signalName}}({{signal|signature}})");
{% endfor %}
        }
        return QByteArrayLiteral("");
    }
    const QByteArray methodSignature(int index) const override
    {
        switch (index) {
{% for property in interface.properties %}
        case {{loop.index0}}: return QByteArrayLiteral("push{{property|upperfirst}}({{property|signature}})");
{% endfor %}
{% set offset = interface.properties|length %}
{% for operation in interface.operations %}
        case {{loop.index0 + offset}}: return QByteArrayLiteral("{{operation}}({{operation|signature}})");
{% endfor %}
        }
        return QByteArrayLiteral("");
    }
    QMetaMethod::MethodType methodType(int) const override
    {
        return QMetaMethod::Slot;
    }
    const QByteArray typeName(int index) const override
    {
        switch (index) {
{% for property in interface.properties %}
        case {{loop.index0}}: return QByteArrayLiteral("void");
{% endfor %}
{% set offset = interface.properties|length %}
{% for operation in interface.operations %}
        case {{loop.index0 + offset}}: return QByteArrayLiteral("{{operation|returnType}}");
{% endfor %}
        }
        return QByteArrayLiteral("");
    }
    QByteArray objectSignature() const override { return QByteArray{"{{interface|hash}}"}; }

    int _properties[{{interface.properties|length + 1}}];
    int _signals[{{interface.properties|length + interface.signals|length + 1}}];
    int _methods[{{interface.properties|length + interface.operations|length + 1}}];
    int signalArgCount[{{interface.properties|length + interface.signals|length}}];
    const int* signalArgTypes[{{interface.properties|length + interface.signals|length}}];
    int methodArgCount[{{interface.properties|length + interface.operations|length}}];
    const int* methodArgTypes[{{interface.properties|length + interface.operations|length}}];
};
QT_BEGIN_NAMESPACE
QT_END_NAMESPACE


#endif // REP_{{interface|upper}}_SOURCE_H
